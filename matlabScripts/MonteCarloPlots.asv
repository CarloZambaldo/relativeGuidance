function [] = MonteCarloPlots(data)
    phaseID = data.phaseID;
    param = data.param;
    n_population = data.n_population;
    timeHistory = data.timeHistory;
    trajectory = data.trajectory;
    controlAction = data.controlAction;
    OBoTUsage = data.OBoTUsage;
    AgentAction = data.AgentAction; % Azione agente: (timestep, n_simulation)
    fail = data.fail;
    success = data.success;


%%
    failRate = sum(fail)/(n_population)*100;
    fprintf("FAIL RATE: %.2f%%\n",failRate);

    successRate = sum(success)/(n_population)*100;
    fprintf("SUCCESS RATE: %.2f%%\n",successRate);

    %% PLOTTING RELATIVE DYNAMICS INSIDE LVLH FRAME
    fprintf("PLOTTING ...\n");
    % compute actual relative dynamics for each simulation

    figure()
    % plot constraints
    quiver3(0,0,0,1,0,0,'r','LineWidth',1);
    hold on
    quiver3(0,0,0,0,1,0,'r','LineWidth',1);
    quiver3(0,0,0,0,0,1,'r','LineWidth',1);
    plot3(0,0,0,'r*','LineWidth',2)

    terminalState = zeros(1,6,length(n_population));
    for sim_id = 1:n_population
        fprintf(" PLOT %d OUT OF %d\n",sim_id,n_population)
        soluz = trajectory(:,:,sim_id);

        indicezeri = soluz(:,7:12) == 0;
        soluz(indicezeri,1:6) = 0;

        indiceValori = ~(soluz(:,1) == 0 & soluz(:,2) == 0 & soluz(:,3) == 0);
        soluz = soluz(indiceValori,:);
        time = timeHistory(indiceValori);

        relDynami = zeros(length(time),6);

        for id = 1:length(time)
            [rotatedRelativeState] = convert_S_to_LVLH(soluz(id,1:6)',soluz(id,7:12)'-soluz(id,1:6)',param);
            relDynami(id,1:6) = rotatedRelativeState;
        end

        terminalState(:,:,sim_id) = relDynami(end,1:6);

        relDynami = relDynami.*param.xc;
        plot3(relDynami(1,1),relDynami(1,2),relDynami(1,3),'ok','LineWidth',1)
        plot3(relDynami(:,1),relDynami(:,2),relDynami(:,3),'LineWidth',1.2);
    end

    if phaseID == 1
        plotConstraintsVisualization(1e3,'S','yellow')
        plotConstraintsVisualization(200,'S')
        plotConstraintsVisualization(2.5e3,'S','Color','black')
    elseif phaseID == 2
        plotConstraintsVisualization(1e3,'C')
    end

    fprintf("RENDERING ...\n\n");
    legend("Target LVLH","","","","","Initial Positions",'Location','best')
    axis equal
    xlabel("R-bar [km]")
    ylabel("V-bar [km]")
    zlabel("H-bar [km]")

    title("Relative Dynamics")
    grid on


    %% second plot
    figure()
    % convert to m/s
    terminalState_conv = terminalState.*param.xc*1e3;
    terminalState_conv(:,4:6,:) = terminalState_conv(:,4:6,:)./param.tc;

    % plots
    for sim_id = 1:n_population
        subplot(2,2,1)
        plot(terminalState_conv(:,3,sim_id)*1e2,terminalState_conv(:,1,sim_id)*1e2,'b.','MarkerSize',8);
        hold on;

        subplot(2,2,2)
        plot(terminalState_conv(:,2,sim_id)*1e2,terminalState_conv(:,1,sim_id)*1e2,'b.','MarkerSize',8);
        hold on;

        subplot(2,2,3)
        plot(terminalState_conv(:,6,sim_id),terminalState_conv(:,4,sim_id),'b.','MarkerSize',8);
        hold on;

        subplot(2,2,4)
        plot(terminalState_conv(:,5,sim_id),terminalState_conv(:,4,sim_id),'b.','MarkerSize',8);
            hold on;

    end

    subplot(2,2,1)
    grid minor
    axis equal
    xline(0,'Color','black')
    yline(0,'Color','black')
    xlim([-11, 11])
    ylim([-11, 11])
    xlabel("R-BAR [cm]");
    ylabel("H-BAR [cm]");
    title("position")

    subplot(2,2,2)
    grid minor
    axis equal
    xline(0,'Color','black')
    yline(0,'Color','black')
    xlim([-11, 11])
    ylim([-11, 11])
    xlabel("R-BAR [cm]");
    ylabel("V-BAR [cm]");
    title("position")

    subplot(2,2,3)
    grid minor
    axis equal
    xline(0,'Color','black')
    yline(0,'Color','black')
    xlim([-.1, .1])
    ylim([-.1, .1])
    xlabel("R-BAR [m/s]");
    ylabel("H-BAR [m/s]");
    title("velocity")

    subplot(2,2,4)
    grid minor
    axis equal
    xline(0,'Color','black')
    yline(0,'Color','black')
    xlim([-.1, .1])
    ylim([-.1, .1])
    xlabel("R-BAR [m/s]");
    ylabel("V-BAR [m/s]");
    title("velocity")




    %% add a plot on the controlAction
    if isfield(data,"controlAction")
        % Supponiamo che data sia una struttura con i campi trajectory e controlAction.
        % Ecco come creare le variabili e calcolare la norma della control action media rispetto alla norma della posizione.
        
        % Inizializza array per le norme
        norm_distances = [];
        norm_controls = [];
    
        % Calcolo delle norme per ogni simulazione
        for sim_id = 1:n_population
            % Norma delle distanze (x, y, z)
            positions = trajectory(:, 1:3, sim_id); % Prendi solo x, y, z
            distances = vecnorm(positions, 2, 2);   % Norma euclidea r = sqrt(x^2 + y^2 + z^2)
    
            % Norma della control action
            controls = controlAction(:, :, sim_id); % Prendi i controlli
            control_norm = vecnorm(controls, 2, 2); % Norma euclidea dei controlli
    
            % Salva i risultati
            norm_distances = [norm_distances; distances];
            norm_controls = [norm_controls; control_norm];
        end
    
        % Definizione dei bin per aggregare le distanze
        minDist = min(norm_distances);
        maxDist = max(norm_distances);
        nBins = 50;  % Numero di bin
        binEdges = linspace(minDist, maxDist, nBins+1);
        binCenters = (binEdges(1:end-1) + binEdges(2:end)) / 2;
    
        % Media della norma della control action per bin
        average_controls = zeros(1, nBins);
        for b = 1:nBins
            % Trova gli indici delle distanze che appartengono al bin
            inBin = norm_distances >= binEdges(b) & norm_distances < binEdges(b+1);
    
            % Calcola la media della norma della control action per questo bin
            if any(inBin)
                average_controls(b) = mean(norm_controls(inBin));
            else
                average_controls(b) = NaN; % Per bin vuoti
            end
        end
    
        % Rimuovi eventuali NaN per evitare problemi nel plot
        validIndices = ~isnan(average_controls);
        binCenters = binCenters(validIndices);
        average_controls = average_controls(validIndices);
    
        % Plot della media della norma della control action rispetto alla norma della distanza
        figure;
        plot(binCenters, average_controls, 'b-', 'LineWidth', 1.5);
        grid on;
        xlabel('Norma della distanza');
        ylabel('Norma media della control action');
        title('Norma media della control action rispetto alla norma della distanza');
    end
    
    %% add a plot on the AgentAction

    % Numero di simulazioni
    nTimeSteps = size(trajectory, 1);

    % Inizializza array per le norme delle distanze
    norm_distances = [];
    agent_actions = [];

    % Calcolo delle norme delle distanze e raccolta delle azioni
    for sim_id = 1:n_population
        % Norma delle distanze (x, y, z)
        positions = trajectory(:, 1:3, sim_id);
        distances = vecnorm(positions, 2, 2);

        % Azioni dell'agente
        actions = AgentAction(:, sim_id);

        % Salva i risultati
        norm_distances = [norm_distances; distances];
        agent_actions = [agent_actions; actions];
    end

    % Definizione dei bin per aggregare le distanze
    minDist = min(norm_distances);
    maxDist = max(norm_distances);
    nBins = 50;  % Numero di bin
    binEdges = linspace(minDist, maxDist, nBins+1);
    binCenters = (binEdges(1:end-1) + binEdges(2:end)) / 2;

    % Inizializza array per frequenze
    action_distribution = zeros(nBins, 3);  % Per azioni 0, 1, 2
    predominant_action = zeros(1, nBins);  % Azione predominante

    % Calcola la distribuzione delle azioni per ciascun bin
    for b = 1:nBins
        % Trova gli indici delle distanze che appartengono al bin
        inBin = norm_distances >= binEdges(b) & norm_distances < binEdges(b+1);

        if any(inBin)
            % Conta le frequenze delle azioni nel bin
            actions_in_bin = agent_actions(inBin);
            action_distribution(b, 1) = sum(actions_in_bin == 0);  % Azione 0
            action_distribution(b, 2) = sum(actions_in_bin == 1);  % Azione 1
            action_distribution(b, 3) = sum(actions_in_bin == 2);  % Azione 2

            % Azione predominante (moda)
            [~, predominant_action(b)] = max(action_distribution(b, :));
        else
            predominant_action(b) = NaN;  % Bin vuoto
        end
    end

    % Normalizza la distribuzione per rappresentarla in percentuale
    action_distribution = action_distribution ./ sum(action_distribution, 2) * 100;

    % Plot della distribuzione delle azioni
    figure;
    subplot(2,2,[1 3])
    bar(binCenters, action_distribution, 'stacked');
    colormap([0.7 0.7 0.7; 0.4 0.4 0.8; 0.8 0.4 0.4]);  % Colori per azioni
    grid on;
    xlabel('Norma della distanza');
    ylabel('Distribuzione delle azioni (%)');
    title('Distribuzione delle azioni dell''agente rispetto alla norma della distanza');
    legend('Azione 0', 'Azione 1', 'Azione 2', 'Location', 'best');

    % Plot dell'azione predominante
    subplot(2,2,2)
    plot(binCenters, predominant_action, 'b.-', 'LineWidth', 1.5);
    grid on;
    xlabel('Norma della distanza');
    ylabel('Azione predominante');
    title('Azione predominante rispetto alla norma della distanza');
    ylim([-0.5, 2.5]);  % Per evidenziare i valori discreti 0, 1, 2
    yticks(0:2);
    
    %%
    % Calcola la norma della posizione
    norm_distances = [];
    usage_flags = [];

    for sim_id = 1:n_population
        % Norma della distanza per la simulazione corrente
        positions = trajectory(:, 1:3, sim_id); % Prendi solo x, y, z
        distances = vecnorm(positions, 2, 2);   % Norma euclidea

        % Flag di utilizzo della traiettoria ottimale
        usage = OBoTUsageHistory(:, sim_id);

        % Salva i dati
        norm_distances = [norm_distances; distances];
        usage_flags = [usage_flags; usage];
    end

    % Definizione dei bin per aggregare le distanze
    minDist = min(norm_distances);
    maxDist = max(norm_distances);
    nBins = 50;  % Numero di bin
    binEdges = linspace(minDist, maxDist, nBins+1);
    binCenters = (binEdges(1:end-1) + binEdges(2:end)) / 2;

    % Calcola la frequenza d'uso della traiettoria ottimale per bin
    optimal_trajectory_usage = zeros(1, nBins);
    for b = 1:nBins
        % Trova gli indici delle distanze che appartengono al bin
        inBin = norm_distances >= binEdges(b) & norm_distances < binEdges(b+1);

        % Calcola la percentuale d'uso della traiettoria ottimale
        if any(inBin)
            optimal_trajectory_usage(b) = mean(usage_flags(inBin)) * 100; % Percentuale
        else
            optimal_trajectory_usage(b) = NaN; % Gestisce bin vuoti
        end
    end

    % Rimuovi eventuali NaN per evitare problemi nel plot
    validIndices = ~isnan(optimal_trajectory_usage);
    binCenters = binCenters(validIndices);
    optimal_trajectory_usage = optimal_trajectory_usage(validIndices);

    % Plot della frequenza d'uso della traiettoria ottimale rispetto alla norma della distanza
    subplot(2,2,4);
    plot(binCenters, optimal_trajectory_usage, 'b-', 'LineWidth', 1.5);
    grid on;
    xlabel('Norma della distanza');
    ylabel('Uso della traiettoria ottimale (%)');
    title('Frequenza d''uso della traiettoria ottimale rispetto alla norma della distanza');

    
    %%  for python use
    fprintf("DONE. Press CTRL+C to close the plots...")
    pause();

end
